# 스터디 참가자
@mo-bile / @chanani / @Eundms

# 🚀 오브젝트 스터디 커리큘럼

---

### 전체 로드맵 요약
| 완료 | 날짜 | 단계 | 주차 | 범위(장) | 핵심 주제 | 실습/산출물 | 면접 포인트 |
|:--:|:--:|--|--:|--|--|--|--|
| [V] | 2026-01-29 | 1단계: 문맥 익히기 | 2주차 | 2, 3장 | 객체 협력, 역할/책임, RDD | Movie–Screening 협력 코드, 메시지 다이어그램 | 다형성으로 if 제거, 컴파일/런타임 의존성 |
| [V] | 2026-02-05 | 2단계: 리팩터링 🔥 | 3주차 | 4장 | 데이터 중심 설계의 함정 | ReservationAgency 문제 코드 분석 | Getter/Setter 지양, 캡슐화 |
| [ ] |  | 2단계: 리팩터링 🔥 | 4주차 | 5장 | GRASP 책임 할당 | 다형성/변경 보호 적용 리팩터링 | 책임 할당 기준 |
| [ ] |  | 3단계: 의존성 관리 | 5주차 | 6, 8장 | 좋은 인터페이스, 의존성 주입 | 디미터/묻지말고시켜라, DI 적용 | CQS, 결합도 |
| [ ] |  | 3단계: SOLID | 6주차 | 9장 | OCP/DIP/Factory | new 제거 리팩터링 | 생성·사용 분리 |
| [ ] |  | 4단계: 상속의 한계 | 7주차 | 10장 | 취약한 기반 클래스 | Phone 상속 문제 재현 | 상속의 단점 |
| [ ] |  | 4단계: 합성 | 8주차 | 11장 | 합성으로 유연성 | 요금 정책 합성 | 상속 vs 합성 |
| [ ] |  | 5단계: LSP | 9주차 | 13장 | 서브타이핑 | 직사각형/정사각형 분석 | LSP 기준 |
| [ ] |  | 5단계: 패턴 | 10주차 | 14, 15장 | 일관성/패턴 | 조건·규칙 분리 | 패턴의 본질 |
|


---

# 주차별 상세 계획

| 완료 | 날짜 | 주차 | 학습 포인트 | 반드시 할 것 |
|:--:|:--:|--:|--|--|
| [V] | 2026-01-29 | 2주차 | 책임 먼저 생각하기(RDD) | 협력 다이어그램 직접 작성 |
| [V] | 2026-02-05 | 3주차 | 데이터 중심 설계의 문제 체감 | 변경 시 파급효과 기록 |
| [ ] |  | 4주차 | GRASP로 책임 재배치 | 다형성/변경 보호 적용 |
| [ ] |  | 5주차 | 인터페이스 설계 원칙 | 디미터 위반 코드 제거 |
| [ ] |  | 6주차 | SOLID 실전 적용 | DI/Factory로 리팩터링 |
| [ ] |  | 7주차 | 상속의 함정 경험 | 중복/결합도 포인트 정리 |
| [ ] |  | 8주차 | 합성으로 문제 해결 | 런타임 조합 코드 작성 |
| [ ] |  | 9주차 | 올바른 상속 기준 | LSP 위반 사례 설명 연습 |
| [ ] |  | 10주차 | 일관성 있는 협력 | 패턴으로 정리 |



> "설계는 코드를 배치하는 것입니다." — 직접 리팩터링하며 체득하세요.

# 주차별 계획
<details>
<summary>2주차 (2026-01-29) </summary>
2주차 계획 (2026-01-29)2주차(2장~3장)는 객체지향의 문법(Syntax)이 아닌 문맥(Context)을 익히는 단계입니다. 클래스를 먼저 만드는 습관을 버리고, 책임을 중심으로 객체 간의 협력을 그리는 사고방식으로 전환하는 것이 핵심 목표입니다.

 2주차 스터디 학습 방향: 객체지향의 문해력 키우기
학습 범위
2장 (객체지향 프로그래밍) ~ 3장 (역할, 책임, 협력)

1. 코드 너머의 의존성 파악하기 (2장)
단순히 코드를 따라 치는 것을 넘어, 상속과 다형성이 어떻게 if-else 조건문을 제거하는지 확인해야 합니다.
컴파일 타임 의존성과 런타임 의존성이 다르다는 사실이 유연한 설계(OCP)의 핵심임을 이해해야 합니다.
코드는 추상 클래스(DiscountPolicy)에 의존하지만, 실행 시점에는 구체 클래스(AmountDiscountPolicy 등)와 협력한다는 점을 명확히 파악하세요.

2. 구현보다 책임 먼저 생각하기 (3장)
이 책의 핵심 철학인 책임 주도 설계(RDD)의 기초를 다집니다.
“이 객체에 어떤 데이터(필드)가 필요한가?”를 먼저 고민하는 습관을 버려야 합니다.
대신
“이 객체는 무엇을 해야 하는가?(책임)”를 먼저 결정하고,
그 책임을 수행하기 위해 누구와 협력해야 하는지를 고민하는 사고방식을 훈련합니다.

 스터디 실습 과제 (Action Item)
스터디 모임 전에 각자 수행하고, 모임 시간에는 결과물을 비교하며 토론하는 방식을 추천합니다.

 [과제 1] 영화 예매 시스템 코드 필사 및 변형 (Hands-on)
내용
2장에 나오는 Movie, Screening, DiscountPolicy(추상 클래스),
AmountDiscountPolicy, PercentDiscountPolicy 코드를 직접 IDE에 타이핑하여 구현합니다.

핵심 미션
Movie 클래스 코드 내에 if문이나 switch문 없이 할인 정책이 적용되는 과정을 디버거(Debugger)로 추적해 봅니다.

변형 실습
NoneDiscountPolicy(할인이 없는 정책) 클래스를 직접 추가해 봅니다.
이때 Movie 클래스의 코드를 단 한 줄도 수정하지 않고 기능이 확장되는지 확인하세요.
이것이 *개방-폐쇄 원칙(OCP)*을 체감하는 가장 좋은 방법입니다.

 [과제 2] 의존성 다이어그램 그리기 (Visualizing)
내용
작성한 코드의 클래스 다이어그램(정적 구조)과
실제 코드가 실행될 때 객체들이 연결되는 객체 다이어그램(동적 구조)을 각각 그려봅니다.

핵심 미션
Movie가 DiscountPolicy를 바라보는 화살표(컴파일 타임)와
실제 실행 시 Movie 인스턴스가 AmountDiscountPolicy 인스턴스를 바라보는 화살표(런타임)가
어떻게 다른지 그림으로 그려서 스터디원들에게 설명해 봅니다.

 [과제 3] CRC 카드 놀이 (Thinking) – 3장 관련
내용
코딩 전에 인덱스 카드(혹은 포스트잇)를 사용하여
역할(Role), 책임(Responsibility), 협력(Collaboration)을 설계하는 연습을 합니다.

상황
“영화 예매 시스템에 ‘환불’ 기능을 추가한다면?”

핵심 미션
구현(메서드, 변수)을 생각하지 말고,
‘환불하라’는 메시지를 누가 받아야 할지,
그 객체는 누구에게 협력을 요청해야 할지를 카드에 적어보며 설계를 구상합니다.

 스터디 토론 주제 (Interview Prep)
Q. 상속은 언제 사용해야 하나요?
가이드:
단순히 코드를 재사용하기 위해서가 아니라,
부모 클래스와 자식 클래스가 타입 계층(Type Hierarchy)을 이룰 때,
즉 부모가 하는 일을 자식이 대체할 수 있을 때 사용해야 합니다.

Q. 컴파일 타임 의존성과 런타임 의존성이 다르면 왜 좋은가요?
가이드:
코드를 수정하지 않고도 객체를 갈아끼움으로써 기능을 변경·확장할 수 있는
유연성(Flexibility)과 코드를 읽을 때 흐름을 파악하기 어려워지는
복잡성(Complexity)의 트레이드오프에 대해 토론합니다.

Q. 데이터 주도 설계 vs 책임 주도 설계의 차이는?
가이드:
Getter/Setter가 많은 객체(수동적 데이터 저장소)와
스스로 상태를 처리하는 객체(자율적 존재)의 차이를
3장의 내용을 바탕으로 설명할 수 있어야 합니다.

 2주차 스터디 방향
이번 주차는
“객체지향은 클래스를 만드는 것이 아니라, 협력하는 객체들을 만드는 것”이라는
패러다임 전환을 받아들이는 것이 가장 중요합니다
</details>



<details>
<summary>3주차 (2026-02-05) </summary>
3주차 계획 (2026-02-05)3주차(4장)는 이 책에서 가장 중요한 전환점 중 하나인 '설계 품질과 트레이드오프'를 다루는 주간입니다.
2주차(2-3장)에서 객체지향의 이상적인 모습을 배웠다면, 3주차인 이번 주는 "데이터 중심 설계(Data-Centric Design)가 왜 실패하는가?"를 처절하게 경험하는 시간입니다. 저자는 좋은 설계와 나쁜 설계를 대비시켜 볼 때 통찰을 얻기 쉽다고 말합니다.

 3주차 목표: 데이터 중심 설계의 함정 파헤치기
진도: 4장 (설계 품질과 트레이드오프)핵심 주제: 캡슐화(Encapsulation), 응집도(Cohesion), 결합도(Coupling)학습 목표'책임'이 아닌 '데이터'를 중심으로 설계했을 때 발생하는 문제점(캡슐화 위반)을 코드로 확인합니다.Getter/Setter가 남발된 코드가 왜 "절차지향적"이며 "변경에 취약한지" 논리적으로 설명할 수 있어야 합니다.좋은 설계의 척도인 캡슐화, 응집도, 결합도의 의미를 명확히 이해합니다.

 스터디 실습 과제 (Hands-on)
이번 주는 "나쁜 코드"를 직접 작성해보고 그 고통을 느껴보는 것이 핵심입니다.

 [과제 1] 데이터 중심의 영화 예매 시스템 구현하기
내용: 4장에 나오는 데이터 중심의 Movie와 ReservationAgency 코드를 직접 타이핑합니다.확인 포인트:Movie 클래스에 getFee, setFee, getDiscountConditions 같은 접근자/수정자(Getter/Setter)가 가득한 것을 확인하세요.모든 로직이 ReservationAgency라는 하나의 거대한 클래스에 집중되어 있고, Movie나 DiscountCondition은 단지 데이터만 제공하는 수동적인 존재(데이터 덩어리)임을 확인하세요.

 [과제 2] '변경'의 고통 체험하기 (시뮬레이션)
내용: 작성한 코드에 다음 변경 사항을 적용해 보고, 몇 개의 클래스를 고쳐야 하는지 세어봅니다.상황: "할인 조건(DiscountCondition)에 '순번'과 '기간' 외에 '요일' 조건이 추가된다면?"예상 결과DiscountCondition 클래스에 데이터를 추가해야 합니다.Movie 클래스의 접근자도 수정될 수 있습니다.무엇보다 ReservationAgency의 reserve 메서드 안에 있는 거대한 if-else 로직을 전부 뜯어고쳐야 합니다.결론: "데이터 중심 설계는 변경의 파급 효과를 통제하지 못한다(낮은 응집도, 높은 결합도)"는 것을 몸소 체험합니다.

 [과제 3] 캡슐화 위반 사례 찾기 (Rectangle 예제)
내용: 책 118페이지에 나오는 Rectangle(직사각형) 클래스와 AnyClass 예제를 작성합니다.미션:Rectangle의 너비와 높이를 조절하는 로직이 Rectangle 내부가 아닌 외부(AnyClass)에 존재하는 것이 왜 '코드 중복'과 '변경 취약성'을 낳는지 주석으로 정리해 봅니다.

 스터디 토론 주제 (Deep Dive)
면접이나 실무 회의에서 설계를 논의할 때 사용할 수 있는 논리를 다듬어 봅니다.

"Getter/Setter를 쓰는 게 왜 나쁜가요?"가이드: 단순히 데이터를 꺼내는 것이 문제가 아니라, "나 이런 데이터를 가지고 있어"라고 만천하에 광고하는 꼴이기 때문입니다. 이는 나중에 데이터 타입이나 저장 방식이 바뀌면, 그 데이터를 가져다 쓰는 모든 코드를 다 고쳐야 함을 의미합니다(캡슐화 위반)."캡슐화, 응집도, 결합도의 관계는?"가이드: 캡슐화를 지키면(내부 구현을 숨기면), 모듈 안의 응집도는 높아지고(관련된 일만 하게 됨), 모듈 사이의 결합도는 낮아집니다(서로 자세한 건 모름). 즉, 캡슐화가 설계 품질의 제1원칙임을 토론합니다."절차지향과 객체지향의 결정적 차이는?"가이드: 4장의 ReservationAgency처럼 데이터와 프로세스(로직)가 분리되어 있으면 절차지향, 데이터와 그 데이터를 처리하는 프로세스가 하나의 객체 안에 통합되어 있으면 객체지향입니다.

 3주차 학습 팁
"추측하지 마세요": 데이터 중심 설계는 "이 객체에 나중에 이런 데이터가 필요하겠지?"라고 추측하며 데이터를 먼저 때려 넣는 방식입니다. 이 방식이 왜 나쁜지 이번 주에 확실히 못 박아야, 다음 주(5장)에 배울 *책임 주도 설계(어떤 행동이 필요한가?)*의 진가를 알 수 있습니다.성급한 리팩터링 금지: 4장 후반부에 리팩터링을 시도하지만 여전히 만족스럽지 않은 결과가 나옵니다. "아직도 부족하네?"라는 갈증을 느끼는 상태로 3주차를 마무리하는 것이 베스트입니다. 해결책은 4주차(5장 GRASP 패턴)에서 등장합니다.
</details>


