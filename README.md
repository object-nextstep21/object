# 스터디 참가자
@mo-bile / @chanani / @Eundms

# 🚀 오브젝트 스터디 커리큘럼

---

### 전체 로드맵 요약
| 완료 | 날짜 | 단계 | 주차 | 범위(장) | 핵심 주제 | 실습/산출물 | 면접 포인트 |
|:--:|:--:|--|--:|--|--|--|--|
| [V] | 2026-01-29 | 1단계: 문맥 익히기 | 2주차 | 2, 3장 | 객체 협력, 역할/책임, RDD | Movie–Screening 협력 코드, 메시지 다이어그램 | 다형성으로 if 제거, 컴파일/런타임 의존성 |
| [V] | 2026-02-05 | 2단계: 리팩터링 🔥 | 3주차 | 4장 | 데이터 중심 설계의 함정 | ReservationAgency 문제 코드 분석 | Getter/Setter 지양, 캡슐화 |
| [ ] |  | 2단계: 리팩터링 🔥 | 4주차 | 5장 | GRASP 책임 할당 | 다형성/변경 보호 적용 리팩터링 | 책임 할당 기준 |
| [ ] |  | 3단계: 의존성 관리 | 5주차 | 6, 8장 | 좋은 인터페이스, 의존성 주입 | 디미터/묻지말고시켜라, DI 적용 | CQS, 결합도 |
| [ ] |  | 3단계: SOLID | 6주차 | 9장 | OCP/DIP/Factory | new 제거 리팩터링 | 생성·사용 분리 |
| [ ] |  | 4단계: 상속의 한계 | 7주차 | 10장 | 취약한 기반 클래스 | Phone 상속 문제 재현 | 상속의 단점 |
| [ ] |  | 4단계: 합성 | 8주차 | 11장 | 합성으로 유연성 | 요금 정책 합성 | 상속 vs 합성 |
| [ ] |  | 5단계: LSP | 9주차 | 13장 | 서브타이핑 | 직사각형/정사각형 분석 | LSP 기준 |
| [ ] |  | 5단계: 패턴 | 10주차 | 14, 15장 | 일관성/패턴 | 조건·규칙 분리 | 패턴의 본질 |
|


---

# 주차별 상세 계획

| 완료 | 날짜 | 주차 | 학습 포인트 | 반드시 할 것 |
|:--:|:--:|--:|--|--|
| [V] | 2026-01-29 | 2주차 | 책임 먼저 생각하기(RDD) | 협력 다이어그램 직접 작성 |
| [V] | 2026-02-05 | 3주차 | 데이터 중심 설계의 문제 체감 | 변경 시 파급효과 기록 |
| [ ] |  | 4주차 | GRASP로 책임 재배치 | 다형성/변경 보호 적용 |
| [ ] |  | 5주차 | 인터페이스 설계 원칙 | 디미터 위반 코드 제거 |
| [ ] |  | 6주차 | SOLID 실전 적용 | DI/Factory로 리팩터링 |
| [ ] |  | 7주차 | 상속의 함정 경험 | 중복/결합도 포인트 정리 |
| [ ] |  | 8주차 | 합성으로 문제 해결 | 런타임 조합 코드 작성 |
| [ ] |  | 9주차 | 올바른 상속 기준 | LSP 위반 사례 설명 연습 |
| [ ] |  | 10주차 | 일관성 있는 협력 | 패턴으로 정리 |



> "설계는 코드를 배치하는 것입니다." — 직접 리팩터링하며 체득하세요.

# 주차별 계획
<details>
<summary>2주차 (2026-01-29) </summary>
9주 완성 플랜의 **2주차(2장~3장)**는 객체지향의 문법(Syntax)이 아닌 **'문맥(Context)'**을 익히는 단계입니다. 클래스를 먼저 만드는 습관을 버리고, **'책임'을 중심으로 객체 간의 협력**을 그리는 사고방식으로 전환하는 것이 핵심 목표입니다.

스터디원들과 함께 **'실무 적용'**과 **'원리 이해'** 두 마리 토끼를 잡을 수 있는 학습 방향과 실습 과제를 제안합니다.

---

### 🎯 2주차 스터디 학습 방향: "객체지향의 문해력 키우기"

**학습 범위:** **2장 (객체지향 프로그래밍)** ~ **3장 (역할, 책임, 협력)**

**1. 코드 너머의 '의존성' 파악하기 (2장)**
*   단순히 코드를 따라 치는 것을 넘어, **상속과 다형성**이 어떻게 `if-else` 조건문을 제거하는지 확인해야 합니다.
*   **컴파일 타임 의존성**과 **런타임 의존성**이 다르다는 사실이 유연한 설계(OCP)의 핵심임을 이해해야 합니다. 코드는 추상 클래스(`DiscountPolicy`)에 의존하지만, 실행 시점에는 구체 클래스(`AmountDiscountPolicy` 등)와 협력한다는 점을 명확히 파악하세요.

**2. 구현보다 '책임' 먼저 생각하기 (3장)**
*   이 책의 핵심 철학인 **'책임 주도 설계(RDD)'**의 기초를 다집니다. "이 객체에 어떤 데이터(필드)가 필요한가?"를 먼저 고민하는 습관을 버려야 합니다.
*   대신 **"이 객체는 무엇을 해야 하는가?(책임)"**를 먼저 결정하고, 그 책임을 수행하기 위해 누구와 협력해야 하는지를 고민하는 사고방식을 훈련합니다.

---

### 💻 스터디 실습 과제 (Action Item)

스터디 모임 전에 각자 수행하고, 모임 시간에는 결과물을 비교하며 토론하는 방식을 추천합니다.

#### ✅ [과제 1] 영화 예매 시스템 코드 필사 및 변형 (Hands-on)
*   **내용:** 2장에 나오는 `Movie`, `Screening`, `DiscountPolicy`(추상 클래스), `AmountDiscountPolicy`, `PercentDiscountPolicy` 코드를 직접 IDE에 타이핑하여 구현합니다.
*   **핵심 미션:**
    1.  `Movie` 클래스 코드 내에 `if`문이나 `switch`문 없이 할인 정책이 적용되는 과정을 디버거(Debugger)로 추적해 봅니다.
    2.  **변형 실습:** `NoneDiscountPolicy`(할인이 없는 정책) 클래스를 직접 추가해 봅니다. 이때 `Movie` 클래스의 코드를 단 한 줄도 수정하지 않고 기능이 확장되는지 확인하세요. 이것이 **개방-폐쇄 원칙(OCP)**을 체감하는 가장 좋은 방법입니다.

#### ✅ [과제 2] 의존성 다이어그램 그리기 (Visualizing)
*   **내용:** 작성한 코드의 **클래스 다이어그램(정적 구조)**과 실제 코드가 실행될 때 객체들이 연결되는 **객체 다이어그램(동적 구조)**을 각각 그려봅니다.
*   **핵심 미션:**
    *   `Movie`가 `DiscountPolicy`를 바라보는 화살표(컴파일 타임)와, 실제 실행 시 `Movie` 인스턴스가 `AmountDiscountPolicy` 인스턴스를 바라보는 화살표(런타임)가 어떻게 다른지 그림으로 그려서 스터디원들에게 설명해 봅니다.

#### ✅ [과제 3] CRC 카드 놀이 (Thinking) - *3장 관련*
*   **내용:** 코딩 전에 인덱스 카드(혹은 포스트잇)를 사용하여 **역할(Role), 책임(Responsibility), 협력(Collaboration)**을 설계하는 연습을 합니다.
*   **상황:** "영화 예매 시스템에 '환불' 기능을 추가한다면?"
*   **핵심 미션:**
    *   구현(메서드, 변수)을 생각하지 말고, **'환불하라'**는 메시지를 누가 받아야 할지, 그 객체는 누구에게 협력을 요청해야 할지를 카드에 적어보며 설계를 구상합니다.

---

### 🗣️ 스터디 토론 주제 (Interview Prep)

면접에서 자주 나오는 질문들에 대해 책의 내용을 바탕으로 답변을 정리해 봅니다.

1.  **"상속은 언제 사용해야 하나요?"**
    *   *가이드:* 단순히 코드를 재사용하기 위해서가 아니라, 부모 클래스와 자식 클래스가 **'타입 계층(Type Hierarchy)'**을 이룰 때, 즉 부모가 하는 일을 자식이 대체할 수 있을 때 사용해야 한다는 점을 2장의 다형성 개념과 연결해 이야기해 봅니다.

2.  **"컴파일 타임 의존성과 런타임 의존성이 다르면 왜 좋은가요?"**
    *   *가이드:* 코드를 수정하지 않고도 객체를 갈아끼움으로써 기능을 변경/확장할 수 있는 **유연성(Flexibility)** 측면과, 반대로 코드를 읽을 때 흐름을 파악하기 어려워지는 **복잡성(Complexity)**의 트레이드오프에 대해 토론합니다.

3.  **"데이터 주도 설계 vs 책임 주도 설계의 차이는?"**
    *   *가이드:* `Getter/Setter`가 많은 객체(수동적 데이터 저장소)와 스스로 상태를 처리하는 객체(자율적 존재)의 차이를 3장의 내용을 바탕으로 설명할 수 있어야 합니다.

---

**💡 2주차 스터디 팁:**
이번 주차는 **"객체지향은 클래스를 만드는 것이 아니라, 협력하는 객체들을 만드는 것"**이라는 패러다임의 전환을 받아들이는 것이 가장 중요합니다. 코드를 짤 때 `class Movie`를 먼저 떠올리기보다 `Movie`라는 객체가 어떤 메시지를 받고 누구에게 메시지를 보낼지를 먼저 상상해 보세요.
</details>



<details>
<summary>3주차 (2026-02-05) </summary>
**3주차(4장)**는 이 책에서 가장 중요한 전환점 중 하나인 **'설계 품질과 트레이드오프'**를 다루는 주간입니다.

2주차(2-3장)에서 객체지향의 이상적인 모습을 배웠다면, 3주차인 이번 주는 **"데이터 중심 설계(Data-Centric Design)가 왜 실패하는가?"**를 처절하게 경험하는 시간입니다. 저자는 좋은 설계와 나쁜 설계를 대비시켜 볼 때 통찰을 얻기 쉽다고 말합니다.

3주차 스터디를 위한 상세 가이드를 정리해 드립니다.

---

### 📅 3주차 목표: 데이터 중심 설계의 함정 파헤치기

*   **진도:** **4장 (설계 품질과 트레이드오프)**
*   **핵심 주제:** 캡슐화(Encapsulation), 응집도(Cohesion), 결합도(Coupling)
*   **학습 목표:**
    1.  '책임'이 아닌 '데이터'를 중심으로 설계했을 때 발생하는 문제점(캡슐화 위반)을 코드로 확인합니다.
    2.  Getter/Setter가 남발된 코드가 왜 "절차지향적"이며 "변경에 취약한지" 논리적으로 설명할 수 있어야 합니다.
    3.  좋은 설계의 척도인 캡슐화, 응집도, 결합도의 의미를 명확히 이해합니다.

---

### 💻 스터디 실습 과제 (Hands-on)

이번 주는 **"나쁜 코드"를 직접 작성해보고 그 고통을 느껴보는 것**이 핵심입니다.

#### ✅ [과제 1] 데이터 중심의 영화 예매 시스템 구현하기
*   **내용:** 4장에 나오는 데이터 중심의 `Movie`와 `ReservationAgency` 코드를 직접 타이핑합니다.
*   **확인 포인트:**
    *   `Movie` 클래스에 `getFee`, `setFee`, `getDiscountConditions` 같은 접근자/수정자(Getter/Setter)가 가득한 것을 확인하세요.
    *   모든 로직이 `ReservationAgency`라는 하나의 거대한 클래스에 집중되어 있고, `Movie`나 `DiscountCondition`은 단지 데이터만 제공하는 수동적인 존재(데이터 덩어리)임을 확인하세요.

#### ✅ [과제 2] '변경'의 고통 체험하기 (시뮬레이션)
*   **내용:** 작성한 코드에 다음 변경 사항을 적용해 보고, 몇 개의 클래스를 고쳐야 하는지 세어봅니다.
    *   **상황:** "할인 조건(`DiscountCondition`)에 '순번'과 '기간' 외에 '요일' 조건이 추가된다면?"
*   **예상 결과:**
    *   `DiscountCondition` 클래스에 데이터를 추가해야 합니다.
    *   `Movie` 클래스의 접근자도 수정될 수 있습니다.
    *   무엇보다 `ReservationAgency`의 `reserve` 메서드 안에 있는 거대한 `if-else` 로직을 전부 뜯어고쳐야 합니다.
    *   **결론:** "데이터 중심 설계는 변경의 파급 효과를 통제하지 못한다(낮은 응집도, 높은 결합도)"는 것을 몸소 체험합니다.

#### ✅ [과제 3] 캡슐화 위반 사례 찾기 (`Rectangle` 예제)
*   **내용:** 책 118페이지에 나오는 `Rectangle`(직사각형) 클래스와 `AnyClass` 예제를 작성합니다.
*   **미션:**
    *   `Rectangle`의 너비와 높이를 조절하는 로직이 `Rectangle` 내부가 아닌 외부(`AnyClass`)에 존재하는 것이 왜 '코드 중복'과 '변경 취약성'을 낳는지 주석으로 정리해 봅니다.

---

### 🗣️ 스터디 토론 주제 (Deep Dive)

면접이나 실무 회의에서 설계를 논의할 때 사용할 수 있는 논리를 다듬어 봅니다.

1.  **"Getter/Setter를 쓰는 게 왜 나쁜가요?"**
    *   *가이드:* 단순히 데이터를 꺼내는 것이 문제가 아니라, "나 이런 데이터를 가지고 있어"라고 만천하에 광고하는 꼴이기 때문입니다. 이는 나중에 데이터 타입이나 저장 방식이 바뀌면, 그 데이터를 가져다 쓰는 모든 코드를 다 고쳐야 함을 의미합니다(캡슐화 위반).

2.  **"캡슐화, 응집도, 결합도의 관계는?"**
    *   *가이드:* **캡슐화**를 지키면(내부 구현을 숨기면), 모듈 안의 **응집도**는 높아지고(관련된 일만 하게 됨), 모듈 사이의 **결합도**는 낮아집니다(서로 자세한 건 모름). 즉, 캡슐화가 설계 품질의 제1원칙임을 토론합니다.

3.  **"절차지향과 객체지향의 결정적 차이는?"**
    *   *가이드:* 4장의 `ReservationAgency`처럼 데이터와 프로세스(로직)가 분리되어 있으면 **절차지향**, 데이터와 그 데이터를 처리하는 프로세스가 하나의 객체 안에 통합되어 있으면 **객체지향**입니다.

---

### 💡 3주차 학습 팁

*   **"추측하지 마세요":** 데이터 중심 설계는 "이 객체에 나중에 이런 데이터가 필요하겠지?"라고 추측하며 데이터를 먼저 때려 넣는 방식입니다. 이 방식이 왜 나쁜지 이번 주에 확실히 못 박아야, 다음 주(5장)에 배울 **책임 주도 설계(어떤 행동이 필요한가?)**의 진가를 알 수 있습니다.
*   **성급한 리팩터링 금지:** 4장 후반부에 리팩터링을 시도하지만 여전히 만족스럽지 않은 결과가 나옵니다. "아직도 부족하네?"라는 갈증을 느끼는 상태로 3주차를 마무리하는 것이 베스트입니다. 해결책은 4주차(5장 GRASP 패턴)에서 등장합니다.
</details>



<details>
<summary> 4주차 (2026-02-12) </summary>
3주차에 **데이터 중심 설계(4장)**의 문제점인  
- 캡슐화 위반  
- 높은 결합도  
- 낮은 응집도  

를 코드로 뼈저리게 느꼈다면, 이제 그 문제를 해결할 **나침반**을 손에 넣을 차례입니다.

4주차는 이 책의 하이라이트 중 하나인 **책임 할당**과 **GRASP 패턴**을 다룹니다.

---

## 📌 4주차 목표
- 책임 할당의 나침반 이해
- GRASP 패턴 정복

### 📖 진도
- 5장: 책임 할당하기

### 🎯 학습 목표
- 데이터(구현)가 아닌 **책임(행동)**을 중심으로 설계를 시작하는 방법 이해
- 책임을 어떤 객체에 줘야 할지 막막할 때 사용하는  
  **GRASP 패턴 (General Responsibility Assignment Software Patterns)**  
  9가지 중 핵심 패턴들을 코드로 체득
- 4장의 절차지향 코드를 객체지향적으로 리팩터링하며  
  **응집도 / 결합도 개선**을 직접 확인

---

## 💻 스터디 실습 과제 (Hands-on)

이번 주차는 **4장의 망가진 코드 `ReservationAgency`를  
5장의 GRASP 패턴을 적용해 살려내는 과정**입니다.

> ⚠️ 반드시 코드를 직접 수정하면서 변화 과정을 관찰하세요.

---

## ✅ 과제 1: 정보 전문가 (Information Expert) 찾기

### 내용
- 4장의 `ReservationAgency`에 뭉쳐 있는 로직을 **각 객체로 이동**
- 책임을 가장 잘 아는 객체에게 위임

### 미션
- `"예매하라"` 메시지를 수신했을 때  
  **상영 시간과 순번을 가장 잘 아는 객체는 누구인가?**  
  → 그 객체(`Screening`)에게 책임 할당
- `"할인 가능 여부를 판단하라"` 메시지를 처리하기 위해  
  요일, 시간 등의 데이터를 가진 객체는 누구인가?  
  → 그 객체(`DiscountCondition`)로 로직 이동

### 체크 포인트
- 핵심 로직 이동 후  
  **`ReservationAgency` 코드가 얼마나 간결해졌는지 확인**

---

## ✅ 과제 2: 창조자 (Creator) 패턴 적용하기

### 내용
- `Reservation` 객체를 **누가 생성(new)하는 것이 가장 결합도가 낮은가** 고민

### 미션
- `Reservation` 생성에 필요한 정보
  - 영화(Movie)
  - 순번(Sequence)
  - 상영 시간(When)
- 위 정보를 가장 많이 알고 있고,  
  `Reservation`을 가장 밀접하게 사용하는 객체 찾기
- 책의 선택: **`Screening`**
  - `Screening` 클래스 안에 `reserve()` 메서드 구현
  - `new Reservation(...)` 코드를 직접 작성

---

## ✅ 과제 3: 변경 보호 & 다형성 (심화)

### 내용
- `DiscountCondition`이 변경될 때  
  **`Movie`까지 수정해야 하는 문제 해결**

### 미션
- 할인 조건(`Sequence`, `Period`)을 체크하는  
  `if-else` 제거
- `DiscountCondition`을 **인터페이스**로 추상화
- 구현 클래스로 분리
  - `SequenceCondition`
  - `PeriodCondition`
- `Movie`는 구체 클래스가 아닌  
  **`DiscountCondition` 인터페이스와만 협력**하도록 수정

### 적용 패턴
- **Polymorphism**
- **Protected Variations**

### 추가 과제
- 이 구조가 **OCP(개방-폐쇄 원칙)**를 어떻게 만족하는지  
  코드 주석으로 설명

---

## 🧠 스터디 토론 주제 (Interview Prep)

면접에서  
> “객체지향 설계는 어떻게 하나요?”

라는 질문을 받았을 때,  
**GRASP 패턴을 근거로 설명할 수 있어야 합니다.**

### 1️⃣ 로직을 어떤 객체에 넣을지 어떻게 결정하나요?
- **Information Expert 패턴** 설명
- “데이터를 가진 객체가 해당 데이터를 처리한다”
- 예시: `DiscountCondition`이 스스로 할인 여부 판단

### 2️⃣ 설계의 품질(응집도 / 결합도)을 높이려면?
- 서로 다른 이유로 변경되는 로직이  
  한 클래스에 섞여 있을 때 발생하는 문제
- 변경 이유에 따라 클래스를 분리하는 과정 설명

### 3️⃣ 절차지향 코드와 객체지향 코드의 차이는?
- 4장 `ReservationAgency`
  - 데이터와 프로세스 분리 (절차지향)
- 5장 리팩터링 코드
  - 데이터와 프로세스 통합 (객체지향)
- **책임 이동 (Shift of Responsibility)** 관점에서 비교

---

## 💡 4주차 TIP

이번 주차는 다음 원칙을 **코드로 구현하는 훈련**입니다.

> ❌ 데이터를 묻지 말고 (Getter 금지)  
> ✅ 작업을 시켜라 (메시지 전송)

코드를 짤 때 끊임없이 질문하세요:

> “이 정보를 **누가 가장 잘 알고 있지?**”

</details>
