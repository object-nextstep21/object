## Chapter 4 예제 비교

### 데이터 중심 설계

첫 예제는 객체가 가져야 할 `상태(데이터)` 를 먼저 결정하고, 그 데이터를 조작하는 로직을 나중에 고민하는 방식입니다.

**특징**

- 객체들이 단순히 데이터 보관소 역할
- `Movie`, `Screening` 등은 필드와 getter, setter만 존재
- `ReservationAgency`에서 모든 데이터를 가져와 절차지향적으로 로직 처리

**문제점**

1. **캡슐화 위반** : `Movie`의 할인 정책 변경 시 `ReservationAgency` 코드 수정 필요
2. **낮은 응집도** : `ReservationAgency`가 과도하게 많은 이유로 변경됨 (할인 정책, 조건 변경 등)

### 책임 중심 설계

두번째 예제는 객체가 수행해야 하는 `행동(책임)`을 먼저 결정하고, 그 행동을 수행하는 데 필요한 데이터를 나중에 결정하는 방식입니다.

**특징**

- 객체가 스스로의 데이터를 제어
- 로직이 여러 객체로 분산되엉 있으며, 객체들은 서로 메시지를 주고 받으며 협력

### 왜 책임 중심 설계가 더 좋을까 ?

책임 중심 설계가 좋은 이유는 `변경에 유연`하기 때문이라고 생각합니다.

**자율적인 객체** : 개체가 자신의 상태를 직접 관리하므로, 내부 구현이 바뀌어도 외부에서는 알 필요가 없다.

**캡슐화** : 단순히 private 변수를 만드는 것이 아니라, 변할 수 있는 것은 `무엇이든 감추는 것이 캡슐화`인 것 같습니다.
> private으로 선언했지만 getter, satter와 같이 외부에서 접근이 가능하면 public으로 선언한 것과 다르지 않다.

**결합도** : 격체 간의 의존성이 낮아져서(메시지?) 시스템의 한 부분을 수정해도 다른 부분까지 영향을 미치지 않는다.

## 개인적인 4장 요약

데이터 중심 설계로 구성된 프로젝트를 책임 중심 설계로 리팩토링하는 과정을 통해, 
`캡슐화, 응집도, 결합도`가 얼마나 중요한지 배웠습니다.

객체에게 데이터를 묻는 것이 아니라 스스로의 상태를 기반으로 판단하고 행동하게끔 `책임을 할당`해야 하며, 
이를 통해 변경에 유연하게 대응할 수 있는 자율적인 객체들의 `협력을 구축`해야 한다는 사실을 깨달았습니다.